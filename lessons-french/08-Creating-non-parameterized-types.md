Creating-non-parameterized.md

**Cr√©ation de types non param√©tr√©s**  

Nous avons d√©j√† abord√© ce que sont les types et pourquoi ils sont utiles dans les le√ßons pr√©c√©dentes. Dans celle-ci, nous allons apprendre √† cr√©er nos propres types.  

### Plan  
- Synonymes de types  
  - Comment les d√©finir  
  - Pourquoi les utiliser  
- Nouveaux types avec `data`  
  - Cr√©ation de types  
  - Utilisation des types  
- Param√®tres de valeur  
- Syntaxe des enregistrements  

---

## **Synonymes de types**  

Lorsque vous avez appris les cha√Ænes de caract√®res (`String`) en Haskell, vous avez d√©couvert que `String` est un sucre syntaxique pour `[Char]`. Cela signifie que `String` et `[Char]` sont √©quivalents et peuvent √™tre utilis√©s de mani√®re interchangeable.  

C'est parce que `String` est un **synonyme de type** pour `[Char]`.  

### **Comment d√©finir des synonymes de types**  
Pour d√©finir un synonyme de type, on utilise le mot-cl√© `type`, suivi du nouveau nom du type et du type existant auquel il est √©quivalent :  

```haskell
type String = [Char]
```  
Vous pouvez nommer le synonyme comme vous le souhaitez, tant qu'il commence par une majuscule.  

Lorsque vous d√©finissez un synonyme de type, vous ne cr√©ez **pas** un nouveau type ! Vous dites simplement √† Haskell qu'un type existant peut √™tre r√©f√©renc√© avec un nom diff√©rent (un synonyme).  

### **Pourquoi utiliser des synonymes de types ?**  
Pourquoi ajouter de la complexit√© sans ajouter de nouvelles fonctionnalit√©s ?  

Parce que les synonymes de types permettent de transmettre **plus d‚Äôinformations** ! Voyons un exemple.  

Imaginez que vous commencez √† travailler avec une biblioth√®que permettant de cr√©er des transactions mon√©taires.  

Vous voulez cr√©er une nouvelle transaction et vous regardez la signature de la fonction que vous devez utiliser :  

```haskell
generateTx :: String -> String -> Int -> String
```  
Pas tr√®s explicite... Vous pouvez deviner que `Int` est la valeur √† transf√©rer, mais que repr√©sentent ces `String` ? Et que contient la `String` renvoy√©e ?  

Comparez maintenant avec cette signature :  

```haskell
generateTx :: Address -> Address -> Value -> Id
```  
Cette deuxi√®me version est **beaucoup plus claire** ! Les deux premiers param√®tres sont des adresses, le troisi√®me est la valeur de la transaction, et la fonction semble retourner l‚Äôidentifiant de la transaction.  

Tout cela rien qu'en lisant la signature du type !  

Voyons ce que nous avons fait pour am√©liorer la compr√©hension :  

```haskell
generateTx :: String -> String -> Int -> String 
generateTx from to value = from ++ to ++ show value
```  
Ajoutons maintenant des synonymes de types :  

```haskell
type Address = String
type Value = Int
type Id = String

generateTx :: Address -> Address -> Value -> Id
generateTx from to value = from ++ to ++ show value
```  
Super facile ! Et si vous voulez v√©rifier la d√©finition d‚Äôun type, vous pouvez ouvrir GHCi, charger le fichier et utiliser :  

```haskell
:i Address
```  
On peut aussi combiner des synonymes pour cr√©er des types plus complexes :  

```haskell
type Name = String
type Address = (String, Int)
type Person = (Name, Address)

bob = ("Bob Smith", ("Main St.", 555)) :: Person
:t bob
:t fst bob
```  
Cela permet de rendre le code plus clair sans modifier le comportement. Mais si nous avons besoin de **cr√©er un tout nouveau type**, nous devons utiliser `data` !  

---

## **D√©finir de nouveaux types avec `data`**  

Nous pouvons cr√©er des nouveaux types ainsi :  

```haskell
data PaymentMethod = Cash | Card | Cryptocurrency

data Color = Red | Green | Blue

data Bool = True | False      -- D√©finition r√©elle de Bool

data Ordering = LT | EQ | GT  -- D√©finition r√©elle de Ordering
```  
Nous utilisons le mot-cl√© `data`.  

- La partie avant le `=` est le **nom du type**.  
- La partie apr√®s le `=` sont les **constructeurs de valeur**.  

Le **symbole `|`** signifie **"ou"**. Ainsi, nous pouvons lire :  

> Le type `PaymentMethod` peut prendre la valeur `Cash`, `Card` ou `Cryptocurrency`.  

üî¥ **Attention** : Le nom du type et ses constructeurs **doivent commencer par une majuscule** !  

### **Utiliser notre nouveau type**  

Nous pouvons maintenant utiliser ce type dans un autre type :  

```haskell
type Name = String
type Address = (String, Int)

data PaymentMethod = Cash | Card | Cryptocurrency deriving (Show)

type Person = (Name, Address, PaymentMethod)

bob = ("Bob Smith", ("Main St.", 555), Cash) :: Person
bob
```  
Cela affiche :  

```haskell
("Bob Smith",("Main St.",555),Cash)
```  
Le `deriving (Show)` permet d'afficher les valeurs dans le terminal.  

On peut aussi utiliser **le pattern matching** :  

```haskell
howItPays :: Person -> String
howItPays (_, _, Cash) = "Paie en liquide"
howItPays (_, _, Card) = "Paie par carte"
howItPays (_, _, Cryptocurrency) = "Paie en cryptomonnaie"

howItPays bob
```  
Cela retourne :  

```haskell
"Paie en liquide"
```  
On peut donc utiliser nos nouveaux types **comme n‚Äôimporte quel autre type** !  

---

## **Param√®tres de valeur**  

Si nous avons besoin d‚Äôun type plus **complexe**, comme une forme g√©om√©trique, nous pouvons utiliser **des param√®tres** dans les constructeurs.  

Par exemple, imaginons que nous voulons repr√©senter **un cercle et un rectangle**.  

Un cercle a un **rayon**. Un rectangle a une **longueur et une largeur**.  

Nous pouvons d√©finir cela ainsi :  

```haskell
data Shape = Circle Float | Rectangle Float Float
```  
Ici, `Circle` prend **un param√®tre** (le rayon) et `Rectangle` prend **deux param√®tres** (les longueurs des c√¥t√©s).  

Et voici quelque chose d‚Äôint√©ressant :  

```haskell
:t Circle
Circle :: Float -> Shape
```  
‚úÖ **`Circle` est une fonction** qui prend un `Float` et retourne un `Shape` !  

Nous pouvons cr√©er des valeurs de notre type comme ceci :  

```haskell
smallCircle = Circle 3
hugeCircle = Circle 100

:t smallCircle
smallCircle :: Shape
```  
Idem pour un rectangle :  

```haskell
rect1 = Rectangle 10 5
rect2 = Rectangle 256 128

:t rect1
rect1 :: Shape
```  
Maintenant, **utilisons ces valeurs** !  

Nous pouvons √©crire une fonction qui calcule l‚Äôaire d‚Äôune `Shape` :  

```haskell
area :: Shape -> Float
area (Circle r) = pi * r^2        -- Pattern matching sur les constructeurs de valeur
area (Rectangle l1 l2) = l1 * l2
```  
Testons :  

```haskell
area smallCircle
area rect2
```  
R√©sultats :  

```haskell
28.274334
32768.0
```  
üöÄ **Nous avons cr√©√© un type vraiment utile !**

Voici la traduction en fran√ßais :  

---

Mais je n‚Äôen ai pas encore fini avec ces formes. J‚Äôen veux plus ! Je veux ajouter des couleurs ! Et des points dans l‚Äôespace 2D qui indiquent la position du centre de la forme !

Pour cela, nous pourrions faire quelque chose comme cette monstruosit√© :

```haskell
data Shape
  = Circle (Float, Float) Float String
  | Rectangle (Float, Float) Float Float String
```
O√π nous ajoutons les points dans l‚Äôespace sous forme de tuples de valeurs `Float`, et les couleurs sous forme de `String`.

Nous pourrions facilement red√©finir la fonction `area` pour ce nouveau type comme ceci :

```haskell
area :: Shape -> Float
area (Circle _ r _) = pi * r^2
area (Rectangle _ l1 l2 _) = l1 * l2
```
Mais ensuite, si nous voulons extraire des champs sp√©cifiques du type `Shape`, nous devons cr√©er une fonction personnalis√©e pour chacun d‚Äôeux :

```haskell
color :: Shape -> String
color (Circle _ _ c) = c
color (Rectangle _ _ _ c) = c

point :: Shape -> (Float, Float)
point (Circle p _ _) = p
point (Rectangle p _ _ _) = p
```
--- Etc...

Nous pouvons am√©liorer cela en d√©finissant des synonymes de types :

```haskell
type Point = (Float,Float)
type Radius = Float
type Width = Float
type Height = Float
type Color = String

data Shape
    = Circle Point Radius Color
    | Rectangle Point Width Height Color
```
Le type est maintenant beaucoup plus lisible, c‚Äôest vrai.

Mais cela fait beaucoup de synonymes de types juste pour am√©liorer la compr√©hension de la signature. Et en plus, cela ne r√©sout pas les autres probl√®mes, plus urgents !

Mais ne vous inqui√©tez pas, Haskell a une solution pour nous ! Voici la *syntaxe des enregistrements* !

---

### Syntaxe des enregistrements (*Record Syntax*)

La *syntaxe des enregistrements* est une fa√ßon alternative de d√©finir des types de donn√©es, qui apporte plusieurs avantages.

Nous allons commencer avec un exemple plus simple, puis nous corrigerons notre type `Shape`.

Supposons que nous voulions cr√©er un type `Employee` contenant le nom de l‚Äôemploy√© et son nombre d‚Äôann√©es d‚Äôexp√©rience.

Sans la syntaxe des enregistrements, nous l‚Äô√©cririons comme ceci :

```haskell
data Employee = Employee String Float
```
Dans ce cas, comme le type n‚Äôa qu‚Äôun seul constructeur, il est courant d‚Äôutiliser le m√™me nom que celui du type. Ce n‚Äôest pas obligatoire, c‚Äôest juste une convention.

Mais avec la syntaxe des enregistrements, nous pouvons faire ceci :

```haskell
data Employee = Employee { name :: String, experienceInYears :: Float } deriving (Show)
```
Comme vous pouvez le voir :

- Les constructeurs de valeur en syntaxe d‚Äôenregistrement ont leurs param√®tres (*champs*) entour√©s d‚Äôaccolades `{}`.
- Chaque champ a un nom commen√ßant par une minuscule suivi de son type.
- Les champs sont s√©par√©s par des virgules.

Nous pouvons maintenant cr√©er des valeurs comme ceci :

```haskell
richard = Employee { name = "Richard", experienceInYears = 7.5 }
```
Haskell nous permet √©galement de r√©cup√©rer les champs directement :

```haskell
name richard      -- "Richard"
experienceInYears richard  -- 7.5
```
Un autre avantage est la mise √† jour facile des champs :

```haskell
newMatt = matt { experienceInYears = 6 }
```
---

### Appliquer cela √† `Shape`

Avant la syntaxe des enregistrements :

```haskell
data Shape
  = Circle (Float, Float) Float String
  | Rectangle (Float, Float) Float Float String
```
Avec la syntaxe des enregistrements :

```haskell
data Shape
  = Circle
      { position :: (Float, Float)
      , radius   :: Float
      , color    :: String
      }
  | Rectangle
      { position :: (Float, Float)
      , width    :: Float
      , height   :: Float
      , color    :: String
      }
  deriving (Show)
```
On peut maintenant cr√©er et manipuler des valeurs plus facilement :

```haskell
circ = Circle { position = (1, 2), radius = 6, color = "Green" }
rect1 = Rectangle (9, 3) 7 3 "Yellow"
rect2 = rect1 {width = 12}
```
Et extraire des champs sans effort :

```haskell
position circ   -- (1.0,2.0)
color rect2     -- "Yellow"
```
---

### Un dernier avantage !

Nous pouvons toujours utiliser le *pattern matching* habituel :

```haskell
area :: Shape -> Float
area (Circle _ r _) = pi * r^2
area (Rectangle _ w h _) = w * h
```
Mais avec la syntaxe des enregistrements, nous pouvons simplifier encore plus :

```haskell
area :: Shape -> Float
area Circle {radius=r} = pi * r^2
area Rectangle {width=w, height=h} = w * h
```
Cela nous permet d‚Äôignorer les champs non pertinents sans avoir √† modifier les fonctions si nous ajoutons de nouveaux champs √† `Shape` !

---

### Conclusion

La syntaxe des enregistrements est particuli√®rement utile pour les types ayant de nombreux champs, comme des configurations d‚Äôapplication ou des formulaires complexes.

Elle rend le code plus lisible, r√©duit les erreurs et facilite l‚Äô√©volution du code.

---

C‚Äôest tout pour aujourd‚Äôhui ! Dans la prochaine le√ßon, nous irons encore plus loin avec des types plus complexes. Assurez-vous de bien assimiler cette le√ßon, et √† bient√¥t ! üöÄ
