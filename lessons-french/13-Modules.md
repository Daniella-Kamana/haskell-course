Modules

Bien sÃ»r ! Voici la traduction en franÃ§ais :  

---

# Modules  
## Plan  
- Importation de modules  
- ContrÃ´le des environnements  
- ContrÃ´le des espaces de noms  
- CrÃ©ation de nos propres modules  
- La bibliothÃ¨que Prelude et les bibliothÃ¨ques standard  

Les leÃ§ons en vidÃ©o et les leÃ§ons Ã©crites diffÃ¨rent, car le format vidÃ©o permet d'expliquer clairement les concepts en refactorisant le code, tandis que la version Ã©crite est plus adaptÃ©e aux explications sÃ©quentielles. Profitez-en ! Si quelque chose ne vous semble pas clair dans un format, peut-Ãªtre le sera-t-il dans l'autre !  

Grosso modo, un module Haskell est simplement une collection de fonctions, de types et de classes de types liÃ©s, que l'on peut importer et utiliser dans notre code. Mais ce n'est pas seulement cela.  

Les modules nous permettent de structurer, de rÃ©utiliser et de maintenir notre code et notre environnement.  

Mais avant d'apprendre Ã  crÃ©er nos propres modules, voyons comment utiliser ceux qui sont prÃ©-dÃ©finis.  

---

## Importation de modules  

Nous allons importer plusieurs modules Ã  plusieurs reprises dans cette leÃ§on. Si vous exÃ©cutez les cellules de maniÃ¨re sÃ©quentielle, vous rencontrerez des erreurs lÃ  oÃ¹ vous ne devriez pas. Dans ces cas-lÃ , redÃ©marrez le noyau (dans le menu **Kernel** ci-dessus) pour supprimer toutes les importations et exÃ©cutez uniquement la cellule en cours, en ignorant les prÃ©cÃ©dentes.  

Imaginons que votre application ait besoin de manipuler des fichiers et des dossiers. Nous pouvons utiliser un module appelÃ© `System.Directory`, qui contient plusieurs fonctions, actions et types liÃ©s Ã  la manipulation de fichiers et de rÃ©pertoires.  

Pour importer ce module, on utilise le mot-clÃ© `import` suivi du nom du module :  

```haskell
import System.Directory
```

Cela doit Ãªtre fait avant de dÃ©finir des fonctions, donc les importations se trouvent gÃ©nÃ©ralement en haut du fichier.  

En ajoutant cette ligne de code, nous avons accÃ¨s Ã  toutes les fonctions, actions, types et classes de types du module `System.Directory`. Vous pouvez consulter la documentation complÃ¨te de ce module ici (lien).  

Une des fonctions fournies est `listDirectory` :  

```haskell
listDirectory :: FilePath -> IO [FilePath]
```

Elle prend en paramÃ¨tre un chemin de type `FilePath` (qui est simplement un alias pour `String`) et renvoie une action IO qui, lorsqu'elle est exÃ©cutÃ©e, retourne une liste de tous les Ã©lÃ©ments (fichiers et dossiers) prÃ©sents dans le rÃ©pertoire indiquÃ©.  

Par exemple, si nous l'utilisons pour voir le contenu du rÃ©pertoire actuel dans ce **Jupyter Notebook**, nous obtenons :  

```haskell
import System.Directory

listDirectory "."
```

Sortie possible :  

```haskell
["23-State-Monad.ipynb","21-Reader-Monad.ipynb","24-Monadic-functions.ipynb", ...]
```

Comme vous pouvez le voir, le dossier actuel contient tous les fichiers des leÃ§ons prÃ©cÃ©dentes.  

### Rechercher un fichier dans un rÃ©pertoire  

Imaginons maintenant que nous voulions Ã©crire une fonction pour trouver des fichiers dans le rÃ©pertoire actuel qui contiennent une certaine chaÃ®ne de caractÃ¨res dans leur nom.  

```haskell
import System.Directory

find' :: String -> IO [FilePath]
find' str = do
  entry <- listDirectory "."
  let found = -- filtrer les entrÃ©es
  return found
```

D'abord, nous rÃ©cupÃ©rons la liste des fichiers et dossiers avec `listDirectory`, puis nous filtrons cette liste.  

Nous pourrions facilement crÃ©er notre propre fonction de filtrage avec du pattern matching et de la rÃ©cursion. Mais, en rÃ©alitÃ©, c'est une fonction assez courante, donc elle existe sÃ»rement dÃ©jÃ  dans une bibliothÃ¨que !  

Effectivement, il existe un module appelÃ© `Data.List` qui contient de nombreuses fonctions pour travailler avec les listes.  

L'une d'elles est `isInfixOf`. Elle prend deux listes et retourne `True` si la premiÃ¨re liste est contenue, intacte et dans le mÃªme ordre, quelque part dans la seconde.  

C'est exactement ce dont nous avons besoin !  

```haskell
import System.Directory
import Data.List

find' :: String -> IO [FilePath]
find' str = do
  entry <- listDirectory "."
  let found = filter (str `isInfixOf`) entry
  return found

find' "11"
```

Sortie possible :  

```haskell
["11-Basic-IO.ipynb"]
```

GÃ©nial ! GrÃ¢ce aux modules contenant du code prÃ©-Ã©crit, nous n'avons pas Ã  tout coder nous-mÃªmes !  

---

## ContrÃ´le de lâ€™environnement  

Notre fonction fonctionne bien, mais son nom est un peu Ã©trange. Pourquoi ne pas lâ€™appeler simplement `find` au lieu de `find'` ?  

Si nous essayons de renommer notre fonction en `find` et de compiler ce code dans un programme Haskell standard, nous obtiendrons cette erreur :  

```
Ambiguous occurrence â€˜findâ€™
    It could refer to either â€˜Data.List.findâ€™ or â€˜YourFileName.findâ€™
```

Le problÃ¨me est clair : il y a deux fonctions `find`, une provenant du module `Data.List` et une que nous avons dÃ©finie. Le compilateur ne sait pas laquelle utiliser.  

Il existe plusieurs solutions :  

### Importer uniquement les fonctions nÃ©cessaires  

Une meilleure approche consiste Ã  importer uniquement les fonctions ou types dont nous avons besoin au lieu du module entier :  

```haskell
import System.Directory (listDirectory) -- importer uniquement listDirectory
import Data.List (isInfixOf)            -- importer uniquement isInfixOf

find :: String -> IO [FilePath]
find str = do
  entry <- listDirectory "."
  let found = filter (str `isInfixOf`) entry
  return found
```

Si nous avons besoin d'importer plusieurs fonctions, nous les sÃ©parons par des virgules :  

```haskell
import Data.List (isInfixOf, sort) -- importer isInfixOf et sort
```

Cela nous permet dâ€™Ã©viter la pollution de notre environnement avec des Ã©lÃ©ments inutiles.  

### Cacher certaines fonctions lors de lâ€™importation  

Si nous avons besoin de la plupart des fonctions dâ€™un module mais quâ€™une seule pose problÃ¨me, nous pouvons utiliser `hiding` :  

```haskell
import System.Directory (listDirectory)
import Data.List hiding (find)  -- importer tout Data.List sauf find
```

---

## ContrÃ´le des espaces de noms  

Si nous avons deux modules avec des fonctions du mÃªme nom (par exemple `filter` de `Data.Map` et `filter` de `Prelude`), nous pouvons utiliser les **espaces de noms** avec `qualified` :  

```haskell
import qualified System.Directory (listDirectory) -- import qualifiÃ©

System.Directory.listDirectory "." -- Ceci fonctionne
listDirectory "." -- Ceci ne fonctionne plus
```

Nous devons maintenant utiliser `System.Directory.listDirectory`, ce qui Ã©vite toute confusion avec d'autres fonctions du mÃªme nom.  

Un autre exemple :  

```haskell
import Data.List hiding (find)
import System.Directory (listDirectory)
import qualified Data.Map

find :: String -> IO (Data.Map.Map Int String)
find str = do
  entry <- listDirectory "."
  let found = sort $ filter (str `isInfixOf`) entry
  let foundMap = Data.Map.fromList $ zip ([1 ..] :: [Int]) found -- Transformer en Map
  return foundMap
```

Sortie possible :  

```haskell
fromList [(1,"08-Creating-non-parameterized-types.ipynb"),(2,"09-Creating-parameterized-and-recursive-types.ipynb"),(3,"10-Creating-Type-Classes.ipynb")]
```

Et voilÃ  ! Nous avons maintenant un meilleur contrÃ´le sur notre environnement et nos importations en Haskell. ðŸŽ‰


Nous n'avons ajoutÃ© qu'une seule ligne de code. Comme nous l'avons dit prÃ©cÃ©demment, les maps stockent des associations entre des clÃ©s uniques et des valeurs. Nous avons les valeurs, mais sans les clÃ©s !

Nous allons utiliser la fonction `zip` pour attribuer une clÃ© unique Ã  chaque valeur. Comme nous l'avons vu dans les devoirs de la leÃ§on sur la rÃ©cursion, la fonction `zip` prend deux listes et renvoie une liste de tuples contenant les paires correspondantes.

Nous associons une liste infinie de nombres ordonnÃ©s Ã  partir de un avec la liste des entrÃ©es filtrÃ©es et triÃ©es. Ainsi, nous devrions obtenir une liste de paires oÃ¹ le premier Ã©lÃ©ment est un nombre et le second est une entrÃ©e.

Heureusement, le module `Data.Map` fournit une fonction appelÃ©e `fromList`, qui prend une liste de paires et retourne une valeur de type `Map`. Dans ce cas, la valeur retournÃ©e est de type `Map Int String` car les clÃ©s sont des `Int` et les valeurs des `String`.

GrÃ¢ce Ã  cette derniÃ¨re fonctionnalitÃ©, nous avons un contrÃ´le total sur nos environnements. Cependant, Ã©crire `Data.Map` partout devient vite lassant. Si nous qualifions les imports avec des noms longs ou plusieurs modules, notre code commence Ã  Ãªtre encombrÃ© et devient plus difficile Ã  lire, comme cette phrase.

Haskell nous permet de renommer l'espace de noms pour le rendre plus pratique. Par exemple :

```haskell
import Data.List hiding (find)
import System.Directory (listDirectory)
import qualified Data.Map as Map -- Renommage de lâ€™espace de noms
```

```haskell
find :: String -> IO (Map.Map Int String)
find str = do
  entry <- listDirectory "."
  let found = sort $ filter (str `isInfixOf`) entry
  let foundMap = Map.fromList $ zip ([1 ..] :: [Int]) found -- Liste vers Map
  return foundMap
```

```haskell
find "Creating"
fromList [(1,"08-Creating-non-parameterized-types.ipynb"),(2,"09-Creating-parameterized-and-recursive-types.ipynb"),(3,"10-Creating-Type-Classes.ipynb")]
```

Remarque : les noms des modules commencent par une majuscule. Si vous les renommez, le nouveau nom doit Ã©galement commencer par une majuscule !

Et comme dernier conseil, nous pouvons combiner toutes ces techniques. Par exemple, si deux modules font Ã  peu prÃ¨s la mÃªme chose et n'ont pas de conflits de noms, nous pourrions leur donner le mÃªme espace de noms et les traiter comme s'ils provenaient d'un seul module.

Cela ne s'applique pas pour l'instant, mais il existe une combinaison d'importations qui le permet. Notre fonction `find` est plutÃ´t bien. Mais quelque chose me dÃ©range : `Map.Map`. `Map.fromList` ne me dÃ©range pas, en fait, je le prÃ©fÃ¨re ! Cela me permet de savoir que `fromList` vient du module `Data.Map`. Mais `Map.Map` est redondant. Bien sÃ»r que le constructeur de type `Map` vient du module `Data.Map` !

Ã‰vitons cette redondance en combinant quelques importations :

```haskell
import Data.List hiding (find)       
import System.Directory (listDirectory)
import qualified Data.Map as Map hiding (Map) -- Import qualifiÃ© + Renommage de l'espace de noms + Masquage de Map
import Data.Map (Map)                         -- Importation uniquement de Map
```

```haskell
find :: String -> IO (Map Int String)
find str = do
  entry <- listDirectory "."
  let found = sort $ filter (str `isInfixOf`) entry
  let foundMap = Map.fromList $ zip ([1 ..] :: [Int]) found
  return foundMap
```

```haskell
find "Creating"
fromList [(1,"08-Creating-non-parameterized-types.ipynb"),(2,"09-Creating-parameterized-and-recursive-types.ipynb"),(3,"10-Creating-Type-Classes.ipynb")]
```

En masquant le constructeur de type `Map` dans l'importation qualifiÃ©e et en l'important sÃ©parÃ©ment, nous l'avons essentiellement retirÃ© de l'espace de noms `Map` et ajoutÃ© Ã  notre espace de noms principal.

Tout le reste reste inchangÃ©, mais maintenant, la signature de `find` est plus lisible.

C'est Ã  peu prÃ¨s tout sur l'importation des modules et la gestion de votre environnement. Mais souvenez-vous, nous avons dit que les modules nous permettent Ã©galement de mieux structurer, rÃ©utiliser et maintenir notre code ? Voyons comment !

---

### CrÃ©er son propre module

Puisque les modules ne sont que des fichiers Haskell ordinaires qui peuvent Ãªtre importÃ©s dans d'autres fichiers Haskell, il est facile d'en crÃ©er un soi-mÃªme.

Imaginons que nous voulions une autre version de la fonction `sum` qui renvoie une erreur si elle est appliquÃ©e Ã  une liste vide au lieu de renvoyer `0`, comme le fait `sum`.

Pour crÃ©er un module qui expose une telle fonction, nous devons d'abord crÃ©er un fichier Haskell que nous appellerons `SumNonEmpty.hs`. En haut de ce fichier, nous Ã©crivons une dÃ©claration de module comme ceci :

```haskell
module SumNonEmpty where
```

Avec cette dÃ©claration, nous avons dÃ©fini le nom de notre module comme `SumNonEmpty`, qui, encore une fois, doit commencer par une majuscule.

Il est recommandÃ© d'avoir le mÃªme nom pour le module et le fichier, bien que ce ne soit pas obligatoire.

Et maintenant, nous pouvons Ã©crire le code que notre module fournit :

```haskell
module SumNonEmpty where

data MyData a b = Error a | Result b deriving (Show)

sumNonEmpty :: Num a => [a] -> MyData String a
sumNonEmpty [] = Error "List is empty"
sumNonEmpty xs = Result (sum xs)
```

Et voilÃ  ! Nous avons crÃ©Ã© notre propre module.

Nous pouvons maintenant l'importer dans un autre fichier (dans le mÃªme dossier) comme n'importe quel autre module :

```haskell
import SumNonEmpty
```

```haskell
sumNonEmpty []     -- Error "List is empty" 
sumNonEmpty [1..3] -- Result 6
```

Dans l'exemple prÃ©cÃ©dent, le module exportÃ© se trouve dans le mÃªme dossier que le fichier qui l'importe. Mais ils pourraient Ãªtre placÃ©s Ã  diffÃ©rents endroits. Dans ce cas, l'importation elle-mÃªme indique oÃ¹ se trouve le code.

Par exemple :

```haskell
import Data.Time.Calendar
import Data.Time.Clock.System
```

On peut en dÃ©duire que les fichiers sont organisÃ©s ainsi :

```
Data
  | 
  |--- Time
         |
         |--- Calendar.hs 
         |--- Clock
                 | 
                 |--- System.hs
```

---

### ContrÃ´le des exports

Dans l'exemple prÃ©cÃ©dent, notre module exporte tout ce qui est dÃ©clarÃ© dans son fichier. Mais parfois, on ne veut pas tout exposer, comme dans le cas d'une fonction d'aide interne :

```haskell
module SumNonEmpty1 where

errorMessage1 = "List is empty"

data MyData1 a b = Error1 a | Result1 b deriving (Show)

sumNonEmpty1 :: Num a => [a] -> MyData1 String a
sumNonEmpty1 [] = Error1 errorMessage1
sumNonEmpty1 xs = Result1 (sum xs)
```

Ici, `errorMessage1` est accessible Ã  lâ€™extÃ©rieur, mais cela nâ€™a pas de sens. La solution est dâ€™indiquer explicitement ce que le module exporte :

```haskell
module SumNonEmpty2 (sumNonEmpty2, MyData2) where
```

Si nous voulons que les constructeurs du type `MyData2` soient accessibles, nous pouvons les exporter explicitement :

```haskell
module SumNonEmpty2 (sumNonEmpty2, MyData2(..)) where
```

Ou alors, nous pouvons fournir une fonction dâ€™extraction :

```haskell
getResult :: (Num a) => a -> MyData3 String a -> a
getResult def (Result3 x) = x
getResult def _           = def
```

---

### Le module Prelude et les bibliothÃ¨ques standard

Le module `Prelude` est importÃ© par dÃ©faut et fournit des fonctions de base comme `head`, `sum`, et `length`. 

De plus, Haskell propose des bibliothÃ¨ques standard intÃ©grÃ©es, que l'on peut explorer via [Hoogle](https://hoogle.haskell.org/).

---

C'est tout pour aujourd'hui ! ðŸš€
